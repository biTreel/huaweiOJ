/* * Author: biTree * Date: July,20 2016 * middle, maze */#include <iostream>#include <queue>#include <stack>#include <assert.h>using namespace std;struct node{    //node(){}    //node(int a,int b):x(a),y(b){}    int x;    int y;};int **maze;node **path;//node *move=new node [4];node move[]={{0,1},{0,-1},{1,0},{-1,0}};//node move[4]={node(0,1),node(0,-1),node(1,0),node(-1,0)};//node move[4];//move[0]={{0,1};move[1]={0,-1};move[2]={1,0};move[3]={-1,0};void createMaze(int row,int col);bool isPath(int row,int col,int x,int y);void printPath(int row,int col);int main(){    int row;    int col;    cin>>row;    cin>>col;    maze=new int* [row+2];    path=new node* [row];    for(int i=0;i!=row+2;++i){        maze[i]=new int [col+2];        path[i]=new node [col];    }    createMaze(row,col);    if(isPath(row,col,1,1))        printPath(row,col);    return 0;}void createMaze(int row,int col){    assert(row!=0 && col!=0);    for(int i=0;i!=col+2;++i)        maze[0][i]=maze[row+1][i]=1;    //create the wall    for(int j=0;j!=row+2;++j)        maze[j][0]=maze[j][col+1]=1;    for(int i=1;i!=row+1;++i)       //create maze        for(int j=1;j!=col+1;++j)            cin>>maze[i][j];}bool isPath(int row,int col,int x,int y){    if(x==row && y==col)        return true;    queue<node> q;    //node curr(x,y);    node curr;    curr.x=x;    curr.y=y;    q.push(curr);    maze[curr.x][curr.y]=-1;    //visited    while(!q.empty()){        curr=q.front();        q.pop();        for(int i=0;i!=4;++i){            if(move[i].x+curr.x==row && move[i].y+curr.y==col){                maze[row][col]=-1;  //visited                path[row][col]=curr;                return true;            }            if(maze[move[i].x+curr.x][move[i].y+curr.y]==0){                //node next(move[i].x+curr.x,move[i].y+curr.y);                node next;                next.x=move[i].x+curr.x;                next.y=move[i].y+curr.y;                maze[next.x][next.y]=-1;                q.push(next);                path[next.x][next.y]=curr;            }        }    }    return false;}void printPath(int row,int col){    //node nd(row,col);   //last node    node nd;    nd.x=row;    nd.y=col;    stack<node> s;    while(nd.x!=0 && nd.y!=0){        s.push(nd);        nd=path[nd.x][nd.y];    }    while(!s.empty()){        nd=s.top();        cout<<"("<<nd.x-1<<","<<nd.y-1<<")";        s.pop();    }    cout<<endl;}                        
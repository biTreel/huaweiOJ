/* * Author: biTree * Date: July,04,2016 */#include <iostream>#include <vector>#include <string>#include <algorithm>#include <stdexcept>using namespace std;bool toPostfix(string infixExp,vector<string>& postfixExp);bool isHighEq(char,char);int getResult(const vector<string> postfixExp);long str2L(string str);void print(vector<long> lvec);int main(){    string infixExp;    vector<string> postfixExp;    getline(cin,infixExp);    if(toPostfix(infixExp,postfixExp))        if(0==getResult(postfixExp))            cout<<"true"<<endl;        //cout<<res<<endl;    return 0;}bool isHighEq(char op,char inInfix){    //equal    if('+'==inInfix && '+'==op) return true;    if('+'==inInfix && '-'==op) return true;    if('-'==inInfix && '+'==op) return true;    if('-'==inInfix && '-'==op) return true;    if('*'==inInfix && '*'==op) return true;    if('*'==inInfix && '/'==op) return true;    if('/'==inInfix && '*'==op) return true;    if('/'==inInfix && '/'==op) return true;    //hight    if('+'==inInfix && '*'==op) return true;    if('-'==inInfix && '*'==op) return true;    if('+'==inInfix && '/'==op) return true;    if('-'==inInfix && '/'==op) return true;    //if('('==op) return true;    return false;}bool toPostfix(string infixExp,vector<string>& postfixExp){    if(infixExp.empty())        return false;      vector<char> opStack;    string dat,op;    string::iterator it=infixExp.begin();    while(it != infixExp.end()){        while(isdigit(*it)){            //dat.append(it,it+1);    //append(beg,end)            dat.append(1,*it);            ++it;        }        if(!dat.empty()){   //digit            postfixExp.push_back(dat);            dat.clear();            continue;   //it has point to the first operator        }        else{   //opeartor            char ch=static_cast<char>(*it);            if(opStack.empty()){                opStack.push_back(ch);                ++it;                continue;   //from the begin            }            switch(ch){                case '(':                    opStack.push_back(ch);                    break;                case ')':                    do{                        //op.push_back(opStack.back());   //char to string                        op.append(1,opStack.back());    //oppend(n,c);                        postfixExp.push_back(op);                        opStack.pop_back();  //remove top stack                        op.clear();                        }while(!opStack.empty() && '(' != opStack.back());                    if('('==opStack.back())                        opStack.pop_back();  //pop '('                    break;                case '+': case '-': case '*': case'/':                    if(!isHighEq(opStack.back(),ch))                        opStack.push_back(ch);                    else{                        while(!opStack.empty() ||'(' != opStack.back()){                            if(isHighEq(opStack.back(),ch)){                                //op.push_back(opStack.back());                                op.append(1,opStack.back());                                postfixExp.push_back(op);                                opStack.pop_back();                                op.clear();                            }                            else                                break;                        }                        if('(' == opStack.back()){                            opStack.pop_back();                            opStack.push_back(ch);                        }                        opStack.push_back(ch);                    }                    break;                default:                    throw runtime_error("illegal operator!");                    break;            }        }        ++it;   //point to the next charactor    }    while(!opStack.empty()){        if('(' != opStack.back() && ')' != opStack.back()){            op.push_back(opStack.back());            postfixExp.push_back(op);            opStack.pop_back();            op.clear();        }    }    // ffor test    /*    size_t st=0;    vector<string>::iterator t=postfixExp.begin();    while(t != postfixExp.end())            cout<<*t++<<" ";    cout<<endl;    */    return true;}int getResult(const vector<string> postfixExp){    if(postfixExp.empty())        throw runtime_error("postfixExp is empty!");    vector<long> res;    vector<string>::size_type st=0;    while(st!=postfixExp.size()){        long val=0;        if(isdigit(*(postfixExp[st].begin()))){            val=str2L(postfixExp[st]);            res.push_back(val);        }        else{            long tmp=0;            char ch=static_cast<char>(*(postfixExp[st].begin()));            vector<long>::reverse_iterator r_it=res.rbegin();            switch(ch){                case '+':                    tmp=*r_it++ + *r_it;                    res.pop_back();                    *res.rbegin()=tmp;                    break;                case '-':                    tmp=*r_it++ - *r_it;                    tmp *=-1;                    res.pop_back();                    *res.rbegin()=tmp;                    break;                case '*':                    tmp=*r_it++ * *r_it;                    res.pop_back();                    *res.rbegin()=tmp;                    break;                case '/':                    tmp=static_cast<long>(*(r_it+1) / *r_it);                    res.pop_back();                    *res.rbegin()=tmp;                    break;                default:                    throw runtime_error("eligal operator!");            }        }        ++st;    }    if(1==res.size()){        print(res);        return 0;    }    return -1;}long str2L(string str){    long res=0;    string::iterator it=str.begin();    while(it!=str.end())        res=res*10 + static_cast<long>(*it++ - '0');    return res;}void print(vector<long> lvec){    vector<long>::iterator it=lvec.begin();    while(it!=lvec.end())        cout<<*it++;    cout<<endl;}